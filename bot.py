import logging
import psycopg2
from psycopg2 import pool
import datetime
import asyncio
import os
import threading
import random  # <--- NEW
import time  # <--- THIS WAS MISSING
from game_data import GAME_DATA
from flask import Flask
from telegram import (
    InlineKeyboardButton, InlineKeyboardMarkup, 
    ReplyKeyboardMarkup, KeyboardButton, ReplyKeyboardRemove, 
    Update, error
)
from telegram.ext import (
    ApplicationBuilder, ContextTypes, CommandHandler, 
    CallbackQueryHandler, MessageHandler, filters
)
from telegram.request import HTTPXRequest

# ==============================================================================
# üîê SECURITY & CONFIGURATION
# ==============================================================================
BOT_TOKEN = os.getenv("BOT_TOKEN")
DATABASE_URL = os.getenv("DATABASE_URL")
admin_env = os.getenv("ADMIN_IDS", "")
ADMIN_IDS = [int(x) for x in admin_env.split(",") if x.strip().isdigit()]

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

# ==============================================================================
# üöÄ HIGH-PERFORMANCE ENGINE (RAM Cache & Connection Pool)
# ==============================================================================
# 1. RAM CACHE: Stores who is chatting with whom. Instant access. 0ms Latency.
ACTIVE_CHATS = {} 
# --- GAME STATE & DATA ---
GAME_STATES = {}       # {user_id: {'game': 'tod', 'turn': uid, 'partner': pid}}
GAME_COOLDOWNS = {}    # {user_id: timestamp}

# 2. DB POOL: Keeps connections open so we don't "dial" the DB every time.
DB_POOL = None

def init_db_pool():
    global DB_POOL
    if not DATABASE_URL: return
    try:
        DB_POOL = psycopg2.pool.SimpleConnectionPool(1, 20, dsn=DATABASE_URL)
        print("‚úÖ CONNECTION POOL STARTED.")
    except Exception as e:
        print(f"‚ùå Pool Error: {e}")

def get_conn():
    # Grabs an open line from the pool
    if DB_POOL: return DB_POOL.getconn()
    return None

def release_conn(conn):
    # Puts the line back in the pool
    if DB_POOL and conn: DB_POOL.putconn(conn)

# ==============================================================================
# ‚ù§Ô∏è THE HEARTBEAT
# ==============================================================================
app_flask = Flask(__name__)

@app_flask.route('/')
def health_check():
    return "Bot is Alive!", 200

def run_flask():
    port = int(os.environ.get("PORT", 8080))
    app_flask.run(host="0.0.0.0", port=port)

# ==============================================================================
# üõ†Ô∏è DATABASE SETUP
# ==============================================================================
def init_db():
    init_db_pool() # Start the pool
    conn = get_conn()
    if not conn: return
    cur = conn.cursor()
    
    # Tables
    tables = [
        """CREATE TABLE IF NOT EXISTS users (
            user_id BIGINT PRIMARY KEY, username TEXT, first_name TEXT,
            language TEXT DEFAULT 'English', gender TEXT DEFAULT 'Hidden',
            age_range TEXT DEFAULT 'Hidden', region TEXT DEFAULT 'Hidden',
            interests TEXT DEFAULT '', mood TEXT DEFAULT 'Neutral',
            karma_score INTEGER DEFAULT 100, status TEXT DEFAULT 'idle',
            partner_id BIGINT DEFAULT 0, report_count INTEGER DEFAULT 0,
            banned_until TIMESTAMP, joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );""",
        """CREATE TABLE IF NOT EXISTS chat_logs (
            id SERIAL PRIMARY KEY, sender_id BIGINT, receiver_id BIGINT,
            message TEXT, timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );""",
        """CREATE TABLE IF NOT EXISTS reports (
            id SERIAL PRIMARY KEY, reporter_id BIGINT, reported_id BIGINT,
            reason TEXT, timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );""",
        """CREATE TABLE IF NOT EXISTS user_interactions (
            id SERIAL PRIMARY KEY, rater_id BIGINT, target_id BIGINT,
            score INTEGER, timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );""",
        """CREATE TABLE IF NOT EXISTS feedback (
            id SERIAL PRIMARY KEY, user_id BIGINT, message TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        );"""
    ]
    
    for t in tables: cur.execute(t)
    
    # Migration checks
    try:
        cols = ["username TEXT", "first_name TEXT", "report_count INTEGER DEFAULT 0", 
                "banned_until TIMESTAMP", "gender TEXT DEFAULT 'Hidden'", 
                "age_range TEXT DEFAULT 'Hidden'", "region TEXT DEFAULT 'Hidden'"]
        for c in cols: cur.execute(f"ALTER TABLE users ADD COLUMN IF NOT EXISTS {c};")
    except: pass

    conn.commit()
    cur.close()
    release_conn(conn)
    print("‚úÖ DATABASE SCHEMA READY.")

# ==============================================================================
# ‚å®Ô∏è KEYBOARD LAYOUTS
# ==============================================================================
def get_keyboard_lobby():
    return ReplyKeyboardMarkup([
        [KeyboardButton("üöÄ Start Matching")],
        [KeyboardButton("üéØ Change Interests"), KeyboardButton("‚öôÔ∏è Settings")],
        [KeyboardButton("ü™™ My ID"), KeyboardButton("üÜò Help")]
    ], resize_keyboard=True)

def get_keyboard_searching():
    return ReplyKeyboardMarkup([[KeyboardButton("‚ùå Stop Searching")]], resize_keyboard=True)

def get_keyboard_chat():
    return ReplyKeyboardMarkup([
        [KeyboardButton("üéÆ Games")],
        [KeyboardButton("‚è≠Ô∏è Next"), KeyboardButton("üõë Stop")]
    ], resize_keyboard=True)

def get_keyboard_game():
    return ReplyKeyboardMarkup([[KeyboardButton("üõë Stop Game"), KeyboardButton("üõë Stop Chat")]], resize_keyboard=True)


# ==============================================================================
# üß† MATCHMAKING ENGINE (Fixed Design + Performance)
# ==============================================================================
def find_match(user_id):
    conn = get_conn()
    cur = conn.cursor()
    
    # Fetch Me (Including Mood)
    cur.execute("SELECT language, interests, age_range, mood FROM users WHERE user_id = %s", (user_id,))
    me = cur.fetchone()
    if not me: release_conn(conn); return None, [], "Neutral", "English"
    my_lang, my_interests, my_age, my_mood = me
    my_tags = [t.strip().lower() for t in my_interests.split(',')] if my_interests else []

    # Fetch Dislikes
    cur.execute("SELECT target_id FROM user_interactions WHERE rater_id = %s AND score = -1", (user_id,))
    disliked_ids = {row[0] for row in cur.fetchall()}

    # Fetch Candidates (Including Mood)
    cur.execute("""
        SELECT user_id, language, interests, age_range, mood 
        FROM users 
        WHERE status = 'searching' AND user_id != %s
        AND (banned_until IS NULL OR banned_until < NOW())
    """, (user_id,))
    candidates = cur.fetchall()
    
    best_match, best_score, common_interests = None, -999999, []
    p_mood, p_lang = "Neutral", "English"

    for cand in candidates:
        cand_id, cand_lang, cand_interests, cand_age, cand_mood = cand
        cand_tags = [t.strip().lower() for t in cand_interests.split(',')] if cand_interests else []
        
        score = 0
        if cand_id in disliked_ids: score -= 1000
        
        matched_tags = list(set(my_tags) & set(cand_tags))
        if matched_tags: score += 40
        if cand_lang == my_lang: score += 20
        if cand_age == my_age and cand_age != 'Hidden': score += 10
            
        if score > best_score:
            best_score = score
            best_match = cand_id
            common_interests = matched_tags
            p_mood = cand_mood
            p_lang = cand_lang

    cur.close()
    release_conn(conn)
    return best_match, common_interests, p_mood, p_lang

# ==============================================================================
# üëÆ ADMIN SYSTEM
# ==============================================================================
# ==============================================================================
# üéÆ GAME ENGINE LOGIC
# ==============================================================================
async def offer_game(update, context, user_id, game_name):
    partner_id = ACTIVE_CHATS.get(user_id)
    if not partner_id: return
    
    # Cooldown
    last = GAME_COOLDOWNS.get(user_id, 0)
    if time.time() - last < 60:
        await context.bot.send_message(user_id, f"‚è≥ Wait {int(60 - (time.time() - last))}s before sending another request.")
        return
    GAME_COOLDOWNS[user_id] = time.time()

    # 1. DEFINE RULES
    rules_map = {
        "Truth or Dare": "‚Ä¢ Be honest!\n‚Ä¢ You can answer with Text, Voice, or Photos.\n‚Ä¢ Use 'Ask Your Own' to get creative.",
        "Would You Rather": "‚Ä¢ Vote silently first.\n‚Ä¢ Discuss WHY you chose it.\n‚Ä¢ Next round starts only after BOTH answer.",
        "Rock Paper Scissors": "‚Ä¢ Pick your move.\n‚Ä¢ Best of 3 or 5 wins.\n‚Ä¢ Draws restart the round instantly."
    }
    
    # Smart Lookup (Handles "Rock Paper Scissors|3")
    rule_text = "Have fun!"
    if "Truth" in game_name: rule_text = rules_map["Truth or Dare"]
    elif "Would" in game_name: rule_text = rules_map["Would You Rather"]
    elif "Rock" in game_name: rule_text = rules_map["Rock Paper Scissors"]

    # Suggestion Logic
    all_games = ["Truth or Dare", "Would You Rather", "Rock Paper Scissors"]
    suggestions = [g for g in all_games if g not in game_name] # Loose match
    
    kb = [
        [InlineKeyboardButton("‚úÖ Accept", callback_data=f"game_accept_{game_name}"), InlineKeyboardButton("‚ùå Reject", callback_data="game_reject")],
        [InlineKeyboardButton(f"üí° Suggest {suggestions[0]}", callback_data=f"game_offer_{suggestions[0]}"),
         InlineKeyboardButton(f"üí° Suggest {suggestions[1]}", callback_data=f"game_offer_{suggestions[1]}")]
    ]
    
    # 2. SEND WITH RULES
    await context.bot.send_message(user_id, f"üéÆ **Offered: {game_name}**\n\nüìú **How to Play:**\n{rule_text}\n\n‚è≥ Waiting for partner...", parse_mode='Markdown')
    await context.bot.send_message(partner_id, f"üéÆ **Game Request**\nPartner wants to play **{game_name}**.\n\nüìú **How to Play:**\n{rule_text}", reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')

async def start_game_session(update, context, game_raw, p1, p2):
    # Detect Rounds (Format: "RPS|3")
    rounds = 1
    game_name = game_raw
    if "|" in game_raw:
        game_name = "Rock Paper Scissors"
        rounds = int(game_raw.split("|")[1])

    # Init State with Scoreboard
    # s1 = P1's score, s2 = P2's score, cr = current round
    # Added: 'streak' (for WYR), 'explained' (set of who answered why)
    state = {"game": game_name, "turn": p2, "partner": p2, "status": "playing", "moves": {}, 
             "max_r": rounds, "cur_r": 1, "s1": 0, "s2": 0, "streak": 0, "explained": []}
    
    GAME_STATES[p1] = GAME_STATES[p2] = state
    
    kb = get_keyboard_game()
    await context.bot.send_message(p1, f"üéÆ **Started: {game_name}**", reply_markup=kb, parse_mode='Markdown')
    await context.bot.send_message(p2, f"üéÆ **Started: {game_name}**", reply_markup=kb, parse_mode='Markdown')
    
    if game_name == "Truth or Dare":
        # Turn starts with P2 (The one who accepted)
        await send_tod_turn(context, p2)
    elif game_name == "Would You Rather":
        await send_wyr_round(context, p1, p2)
    elif game_name == "Rock Paper Scissors":
        await send_rps_round(context, p1, p2)

async def send_tod_turn(context, turn_id):
    kb = [[InlineKeyboardButton("üü¢ Truth", callback_data="tod_pick_truth"), InlineKeyboardButton("üî¥ Dare", callback_data="tod_pick_dare")]]
    await context.bot.send_message(turn_id, "ü´µ **Your Turn!** Choose:", reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')

async def send_tod_options(context, target_id, mode):
    # Select 5 random questions
    options = random.sample(GAME_DATA[f"tod_{mode}"], 5)
    
    # Create Menu Text
    msg_text = f"üé≠ **Pick a {mode.upper()}:**\n\n"
    for i, opt in enumerate(options):
        msg_text += f"**{i+1}.** {opt}\n"
    
    # Create Buttons (1-5 and Manual)
    kb = [
        [InlineKeyboardButton("1Ô∏è‚É£", callback_data="tod_send_0"), InlineKeyboardButton("2Ô∏è‚É£", callback_data="tod_send_1"), InlineKeyboardButton("3Ô∏è‚É£", callback_data="tod_send_2")],
        [InlineKeyboardButton("4Ô∏è‚É£", callback_data="tod_send_3"), InlineKeyboardButton("5Ô∏è‚É£", callback_data="tod_send_4")],
        [InlineKeyboardButton("‚úçÔ∏è Ask Your Own", callback_data="tod_manual")]
    ]
    
    # Save options to the Asker's state (target_id)
    if target_id not in GAME_STATES: GAME_STATES[target_id] = {}
    GAME_STATES[target_id]["options"] = options
        
    # Send to the Partner (Asker)
    await context.bot.send_message(target_id, msg_text, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
async def send_wyr_round(context, p1, p2):
    q = random.choice(GAME_DATA["wyr"])
    
    # 1. Put the LONG text in the Message (No limits here)
    msg = f"‚öñÔ∏è **Would You Rather...**\n\nüÖ∞Ô∏è **{q[0]}**\n       ‚ûñ OR ‚ûñ\nüÖ±Ô∏è **{q[1]}**"
    
    # 2. Keep the buttons simple so they never cut off
    kb = [
        [InlineKeyboardButton("üÖ∞Ô∏è Choose Option A", callback_data="wyr_a")],
        [InlineKeyboardButton("üÖ±Ô∏è Choose Option B", callback_data="wyr_b")]
    ]
    
    await context.bot.send_message(p1, msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
    await context.bot.send_message(p2, msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')

async def send_rps_round(context, p1, p2):
    kb = [[InlineKeyboardButton("ü™®", callback_data="rps_rock"), InlineKeyboardButton("üìÑ", callback_data="rps_paper"), InlineKeyboardButton("‚úÇÔ∏è", callback_data="rps_scissors")]]
    await context.bot.send_message(p1, "‚úÇÔ∏è **Shoot!**", reply_markup=InlineKeyboardMarkup(kb))
    await context.bot.send_message(p2, "‚úÇÔ∏è **Shoot!**", reply_markup=InlineKeyboardMarkup(kb))

async def admin_panel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS: return
    conn = get_conn(); cur = conn.cursor()
    
    cur.execute("SELECT COUNT(*) FROM users")
    total = cur.fetchone()[0]
    cur.execute("SELECT COUNT(*) FROM users WHERE status != 'idle'")
    online = cur.fetchone()[0]
    cur.execute("SELECT COUNT(*) FROM users WHERE report_count > 0")
    flagged = cur.fetchone()[0]
    
    cur.execute("SELECT gender, COUNT(*) FROM users GROUP BY gender")
    g_stats = " | ".join([f"{r[0]}:{r[1]}" for r in cur.fetchall()])

    def get_stat(col):
        cur.execute(f"SELECT {col}, COUNT(*) FROM users GROUP BY {col} ORDER BY COUNT(*) DESC LIMIT 3")
        return " | ".join([f"{r[0]}:{r[1]}" for r in cur.fetchall()])

    msg = (f"üëÆ **CONTROL ROOM**\n"
           f"üë• Total: `{total}` | üü¢ Online: `{online}`\n"
           f"‚ö†Ô∏è Flagged: `{flagged}`\n"
           f"üöª **Gender:** {g_stats}\n"
           f"üåç {get_stat('region')}\n\n"
           f"üõ†Ô∏è **COMMANDS:**\n"
           f"‚Ä¢ `/ban ID HOURS` (e.g., /ban 12345 24)\n"
           f"‚Ä¢ `/warn ID REASON` (e.g., /warn 12345 No spam)\n"
           f"‚Ä¢ `/broadcast MESSAGE` (Send to all)\n"
           f"‚Ä¢ `/unban ID` (Via button only)")
    
    kb = [[InlineKeyboardButton("üì¢ Broadcast", callback_data="admin_broadcast_info"), InlineKeyboardButton("üìú Recent Users", callback_data="admin_users")],
          [InlineKeyboardButton("‚ö†Ô∏è Reports", callback_data="admin_reports"), InlineKeyboardButton("üì® Feedbacks", callback_data="admin_feedbacks")],
          [InlineKeyboardButton("üö´ Bans", callback_data="admin_banlist")]]
    
    try:
        if update.callback_query: await update.callback_query.edit_message_text(msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
        else: await update.message.reply_text(msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
    except error.BadRequest: pass
    cur.close(); release_conn(conn)

async def admin_ban_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS: return
    try:
        target = int(context.args[0])
        hours = int(context.args[1])
        conn = get_conn(); cur = conn.cursor()
        ban_until = datetime.datetime.now() + datetime.timedelta(hours=hours)
        cur.execute("UPDATE users SET banned_until = %s WHERE user_id = %s", (ban_until, target))
        conn.commit(); cur.close(); release_conn(conn)
        await update.message.reply_text(f"üî® Banned {target} for {hours}h.")
        
        # Clear RAM cache if online
        if target in ACTIVE_CHATS: del ACTIVE_CHATS[target]
        
        try: await context.bot.send_message(target, f"üö´ You are banned for {hours} hours.")
        except: pass
    except: await update.message.reply_text("Usage: /ban ID HOURS")

async def admin_warn_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS: return
    try:
        target = int(context.args[0])
        reason = " ".join(context.args[1:])
        await context.bot.send_message(target, f"‚ö†Ô∏è **OFFICIAL WARNING**\n\n{reason}", parse_mode='Markdown')
        await update.message.reply_text(f"‚úÖ Warned {target}.")
    except: await update.message.reply_text("Usage: /warn ID REASON")

async def admin_broadcast_execute(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS: return
    msg = " ".join(context.args)
    if not msg: return await update.message.reply_text("Usage: /broadcast MSG")
    conn = get_conn(); cur = conn.cursor()
    cur.execute("SELECT user_id FROM users")
    users = cur.fetchall(); cur.close(); release_conn(conn)
    await update.message.reply_text(f"üì¢ Sending to {len(users)} users...")
    for u in users:
        try: await context.bot.send_message(u[0], f"üì¢ **ANNOUNCEMENT:**\n\n{msg}", parse_mode='Markdown')
        except: pass
    await update.message.reply_text("‚úÖ Broadcast done.")

async def handle_feedback_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    feedback_text = update.message.text.replace("/feedback", "").strip()
    if not feedback_text: await update.message.reply_text("‚ùå Usage: `/feedback message`", parse_mode='Markdown'); return
    conn = get_conn(); cur = conn.cursor()
    cur.execute("INSERT INTO feedback (user_id, message) VALUES (%s, %s)", (user_id, feedback_text))
    conn.commit(); cur.close(); release_conn(conn)
    await update.message.reply_text("‚úÖ **Feedback Sent!**", parse_mode='Markdown')

# ==============================================================================
# üìù ONBOARDING
# ==============================================================================
async def send_onboarding_step(update, step):
    kb = []
    msg = ""
    
    if step == 1:
        msg = "1Ô∏è‚É£ **What's your gender?**"
        kb = [[InlineKeyboardButton("üë® Male", callback_data="set_gen_Male"), InlineKeyboardButton("üë© Female", callback_data="set_gen_Female")], 
              [InlineKeyboardButton("üåà Other", callback_data="set_gen_Other"), InlineKeyboardButton("‚è≠Ô∏è Skip", callback_data="set_gen_Hidden")]]
    
    elif step == 2:
        msg = "2Ô∏è‚É£ **Age Group?**"
        kb = [[InlineKeyboardButton("üë¶ ~18", callback_data="set_age_~18"), InlineKeyboardButton("üß¢ 20-25", callback_data="set_age_20-25")], 
              [InlineKeyboardButton("üíº 25-30", callback_data="set_age_25-30"), InlineKeyboardButton("‚òï 30+", callback_data="set_age_30+")],
              [InlineKeyboardButton("‚è≠Ô∏è Skip", callback_data="set_age_Hidden")]]
    
    elif step == 3:
        msg = "3Ô∏è‚É£ **Primary Language?**"
        kb = [[InlineKeyboardButton("üá∫üá∏ English", callback_data="set_lang_English"), InlineKeyboardButton("üáÆüá≥ Hindi", callback_data="set_lang_Hindi")],
              [InlineKeyboardButton("üáÆüá© Indo", callback_data="set_lang_Indo"), InlineKeyboardButton("üá™üá∏ Spanish", callback_data="set_lang_Spanish")],
              [InlineKeyboardButton("üá´üá∑ French", callback_data="set_lang_French"), InlineKeyboardButton("üáØüáµ Japanese", callback_data="set_lang_Japanese")],
              [InlineKeyboardButton("üåç Other", callback_data="set_lang_Other"), InlineKeyboardButton("‚è≠Ô∏è Skip", callback_data="set_lang_English")]]
    
    elif step == 4:
        msg = "4Ô∏è‚É£ **Region?**"
        kb = [[InlineKeyboardButton("üåè Asia üóª", callback_data="set_reg_Asia"), InlineKeyboardButton("üåç Europe üç∑", callback_data="set_reg_Europe")],
              [InlineKeyboardButton("üåé America üóΩ", callback_data="set_reg_America"), InlineKeyboardButton("üåç Africa üå¥", callback_data="set_reg_Africa")],
              [InlineKeyboardButton("‚è≠Ô∏è Skip", callback_data="set_reg_Hidden")]]
    
    elif step == 5:
        msg = "5Ô∏è‚É£ **Current Mood?**"
        kb = [[InlineKeyboardButton("üòÉ Happy", callback_data="set_mood_Happy"), InlineKeyboardButton("üòî Sad", callback_data="set_mood_Sad")],
              [InlineKeyboardButton("üò¥ Bored", callback_data="set_mood_Bored"), InlineKeyboardButton("ü§î Don't Know", callback_data="set_mood_Confused")],
              [InlineKeyboardButton("ü•Ä Lonely", callback_data="set_mood_Lonely"), InlineKeyboardButton("üò∞ Anxious", callback_data="set_mood_Anxious")],
              [InlineKeyboardButton("‚è≠Ô∏è Skip", callback_data="set_mood_Neutral")]]
    
    elif step == 6:
        msg = "6Ô∏è‚É£ **Final Step! Interests**\n\nType keywords (e.g., *Music, Movies,kdrama..*) or click Skip."
        kb = [[InlineKeyboardButton("‚è≠Ô∏è Skip & Finish", callback_data="onboarding_done")]]

    try:
        if update.callback_query: await update.callback_query.edit_message_text(msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
        else: await update.message.reply_text(msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
    except: pass


# ==============================================================================
# üì± MAIN CONTROLLER
# ==============================================================================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    conn = get_conn(); cur = conn.cursor()
    cur.execute("SELECT banned_until, gender FROM users WHERE user_id = %s", (user.id,))
    data = cur.fetchone()
    if data and data[0] and data[0] > datetime.datetime.now():
        await update.message.reply_text(f"üö´ Banned until {data[0]}."); cur.close(); release_conn(conn); return
    
    cur.execute("""INSERT INTO users (user_id, username, first_name) VALUES (%s, %s, %s) 
                   ON CONFLICT (user_id) DO UPDATE SET username = %s, first_name = %s""", 
                   (user.id, user.username, user.first_name, user.username, user.first_name))
    conn.commit(); cur.close(); release_conn(conn)

    welcome_msg = "üëã **Welcome to OmeTV Chatbotü§ñ**\n\nConnect with strangers worldwide üåç\nNo names. No login.End to End encrypted\n\n*Let's vibe check.* üëá"
    if not data or data[1] == 'Hidden':
        await update.message.reply_text(welcome_msg, reply_markup=ReplyKeyboardRemove(), parse_mode='Markdown')
        await send_onboarding_step(update, 1)
    else:
        msg = await update.message.reply_text("üîÑ Loading...", reply_markup=ReplyKeyboardRemove())
        try: await context.bot.delete_message(chat_id=user.id, message_id=msg.message_id)
        except: pass
        await show_main_menu(update)

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    msg = (
        "üÜò **USER GUIDE**\n\n"
        "**1. How to Chat?**\n"
        "Click 'üöÄ Start Matching'. You will be connected to a random stranger. Say Hi!\n\n"
        "**2. The Games**\n"
        "Click 'üéÆ Games' inside a chat to challenge your partner. Both must accept to play.\n\n"
        "**3. Safety First**\n"
        "‚Ä¢End to End Encrypted, Your identity is hidden.\n"
        "‚Ä¢ To leave: Click 'üõë Stop'.\n"
	"‚Ä¢ To change Profile: Click '‚öôÔ∏è Settings'.\n"
	"‚Ä¢ View your Profile: Click 'ü™™ My ID'.\n"
        "‚Ä¢ To report abuse: Click '‚ö†Ô∏è Report' after ending chat.\n"
	"‚Ä¢ üõëüõëBehave Respectful to avoid Permanent **BAN**.üõëüõë\n\n"
        "**4. Commands**\n"
        "/start - Restart Bot\n"
        "/feedback [msg] - Send your feedback to Admin about Bot"
    )
    await update.message.reply_text(msg, parse_mode='Markdown')

async def handle_text_input(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not update.message: return
    text = update.message.text
    user_id = update.effective_user.id

    # 1. GAME ANSWER LOGIC (The Answer)
    # Check if this user is supposed to be answering a question

    # 3. ONBOARDING
    if context.user_data.get("state") == "ONBOARDING_INTEREST":
        await update_user(user_id, "interests", text)
        context.user_data["state"] = None
        await update.message.reply_text("‚úÖ **Ready!**", reply_markup=get_keyboard_lobby(), parse_mode='Markdown'); return

    # 4. BUTTON TEXT TRIGGERS
    if text == "üöÄ Start Matching": await start_search(update, context); return
    if text in ["üõë Stop", "üõë Stop Chat"]: await stop_chat(update, context); return
    if text == "‚è≠Ô∏è Next": await stop_chat(update, context, is_next=True); return
    if text == "‚ùå Stop Searching": await stop_search_process(update, context); return
    if text == "üéØ Change Interests": context.user_data["state"] = "ONBOARDING_INTEREST"; await update.message.reply_text("üëá Type interests:(separate two interest with coma)", reply_markup=ReplyKeyboardRemove()); return
    if text == "‚öôÔ∏è Settings": 
        kb = [
            [InlineKeyboardButton("üöª Gender", callback_data="set_gen_menu"), InlineKeyboardButton("üéÇ Age", callback_data="set_age_menu")],
            [InlineKeyboardButton("üó£Ô∏è Lang", callback_data="set_lang_menu"), InlineKeyboardButton("üé≠ Mood", callback_data="set_mood_menu")],
            [InlineKeyboardButton("üîô Close", callback_data="close_settings")]
        ]
        await update.message.reply_text("‚öôÔ∏è **Settings:**", reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown'); return
    if text == "ü™™ My ID": await show_profile(update, context); return
    if text == "üÜò Help": await help_command(update, context); return
    
    # 5. GAME MENU
    if text == "üéÆ Games":
        kb = [[InlineKeyboardButton("üòà Truth or Dare", callback_data="game_offer_Truth or Dare")],
              [InlineKeyboardButton("üé≤ Would You Rather", callback_data="game_offer_Would You Rather")],
              [InlineKeyboardButton("‚úÇÔ∏è Rock Paper Scissors", callback_data="rps_mode_select")]]
        await update.message.reply_text("üéÆ **Game Center**", reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown'); return
    
    if text == "üõë Stop Game":
        pid = ACTIVE_CHATS.get(user_id)
        if user_id in GAME_STATES: del GAME_STATES[user_id]
        if pid and pid in GAME_STATES: del GAME_STATES[pid]
        await update.message.reply_text("üõë Game Stopped.", reply_markup=get_keyboard_chat())
        if pid: await context.bot.send_message(pid, "üõë Partner stopped game.", reply_markup=get_keyboard_chat())
        return

    # 6. COMMANDS (Robust & Clean)
    if text.startswith("/"):
        cmd = text.lower().strip() # Fixes "Stop" or "/stop "
        
        # User Commands
        if cmd == "/stop": 
            await stop_chat(update, context)
            return
        if cmd == "/next": 
            await stop_chat(update, context, is_next=True)
            return
        
        # Admin Commands
        if cmd == "/admin": await admin_panel(update, context); return
        if cmd.startswith("/ban"): await admin_ban_command(update, context); return
        if cmd.startswith("/warn"): await admin_warn_command(update, context); return
        if cmd.startswith("/broadcast"): await admin_broadcast_execute(update, context); return
        if cmd.startswith("/feedback"): await handle_feedback_command(update, context); return

    await relay_message(update, context)
# ==============================================================================
# üîå FAST CONNECTION LOGIC (RAM + DB)
# ==============================================================================
async def stop_search_process(update, context):
    user_id = update.effective_user.id
    conn = get_conn(); cur = conn.cursor()
    # 1. Set Status to Idle
    cur.execute("UPDATE users SET status = 'idle' WHERE user_id = %s", (user_id,))
    conn.commit(); cur.close(); release_conn(conn)
    
    # 2. Send Feedback & Show Lobby
    try:
        if update.callback_query:
            await update.callback_query.message.reply_text("üõë **Search Stopped.**", reply_markup=get_keyboard_lobby(), parse_mode='Markdown')
        else:
            await update.message.reply_text("üõë **Search Stopped.**", reply_markup=get_keyboard_lobby(), parse_mode='Markdown')
    except: pass

async def start_search(update, context):
    user_id = update.effective_user.id
    if user_id in ACTIVE_CHATS:
        await update.message.reply_text("‚õî **Already in chat!**", parse_mode='Markdown'); return

    conn = get_conn(); cur = conn.cursor()
    cur.execute("UPDATE users SET status = 'searching' WHERE user_id = %s", (user_id,))
    conn.commit()
    
    # üîî NEW: WAKE UP WAITERS
    cur.execute("SELECT user_id FROM users WHERE status = 'waiting_notify' AND user_id != %s", (user_id,))
    waiters = cur.fetchall()
    for w in waiters:
        try: await context.bot.send_message(w[0], "üîî **Someone just joined!**\nClick 'üöÄ Start Matching' now to connect!", parse_mode='Markdown')
        except: pass
    
    cur.execute("SELECT interests FROM users WHERE user_id = %s", (user_id,))
    tags = cur.fetchone()[0] or "Any"
    cur.close(); release_conn(conn)
    
    await update.message.reply_text(f"üì° **Scanning...**\nLooking for: `{tags}`...", parse_mode='Markdown', reply_markup=get_keyboard_searching())
    if context.job_queue: context.job_queue.run_once(send_reroll_option, 15, data=user_id)
    await perform_match(update, context, user_id)

async def perform_match(update, context, user_id):
    partner_id, common, p_mood, p_lang = find_match(user_id)
    if partner_id:
        conn = get_conn(); cur = conn.cursor()
        cur.execute("UPDATE users SET status='chatting', partner_id=%s WHERE user_id=%s", (partner_id, user_id))
        cur.execute("UPDATE users SET status='chatting', partner_id=%s WHERE user_id=%s", (user_id, partner_id))
        conn.commit(); cur.close(); release_conn(conn)
        
        # UPDATE RAM CACHE (Instant Relay)
        ACTIVE_CHATS[user_id] = partner_id
        ACTIVE_CHATS[partner_id] = user_id
        
        # DESIGN RESTORED
        common_str = ", ".join(common).title() if common else "Random"
        msg = (f"‚ö° **YOU ARE CONNECTED!**\n\nüé≠ **Mood:** {p_mood}\nüîó **Interest:** {common_str}\n"
               f"üó£Ô∏è **Lang:** {p_lang}\n\n‚ö†Ô∏è *Tip: Say Hi! or Sent a meme*")
        
        kb = get_keyboard_chat()
        await context.bot.send_message(user_id, msg, reply_markup=kb, parse_mode='Markdown')
        try: await context.bot.send_message(partner_id, msg, reply_markup=kb, parse_mode='Markdown')
        except: pass

async def stop_chat(update, context, is_next=False):
    user_id = update.effective_user.id
    
    # Clear RAM Cache immediately
    partner_id = ACTIVE_CHATS.pop(user_id, 0)
    if partner_id and partner_id in ACTIVE_CHATS: del ACTIVE_CHATS[partner_id]

    # Clear Game States on Disconnect
    if user_id in GAME_STATES: del GAME_STATES[user_id]
    if partner_id in GAME_STATES: del GAME_STATES[partner_id]

    # Clear DB
    conn = get_conn(); cur = conn.cursor()
    cur.execute("UPDATE users SET status='idle', partner_id=0 WHERE user_id IN (%s, %s)", (user_id, partner_id))
    conn.commit(); cur.close(); release_conn(conn)
    
    # 1. KEYBOARD FOR ME
    k_me = [
        [InlineKeyboardButton("üëç", callback_data=f"rate_like_{partner_id}"), InlineKeyboardButton("üëé", callback_data=f"rate_dislike_{partner_id}")],
        [InlineKeyboardButton("‚ö†Ô∏è Report", callback_data=f"rate_report_{partner_id}")]
    ]
    
    # 2. KEYBOARD FOR PARTNER
    k_partner = [
        [InlineKeyboardButton("üëç", callback_data=f"rate_like_{user_id}"), InlineKeyboardButton("üëé", callback_data=f"rate_dislike_{user_id}")],
        [InlineKeyboardButton("‚ö†Ô∏è Report", callback_data=f"rate_report_{user_id}")]
    ]
    
    if is_next:
        await update.message.reply_text("‚è≠Ô∏è **Skipping...**", reply_markup=ReplyKeyboardRemove(), parse_mode='Markdown')
        await update.message.reply_text("Please give your Feedback about the Stranger!!", reply_markup=InlineKeyboardMarkup(k_me))
        await start_search(update, context)
    else:
        await update.message.reply_text("üò∂‚Äçüå´Ô∏è **Partner Disconnect.**", reply_markup=get_keyboard_lobby(), parse_mode='Markdown')
        await update.message.reply_text("Please give your Feedback about the Stranger!!", reply_markup=InlineKeyboardMarkup(k_me))

    if partner_id:
        try: 
            await context.bot.send_message(partner_id, "üò∂‚Äçüå´Ô∏è **Partner Disconnected.**", reply_markup=get_keyboard_lobby(), parse_mode='Markdown')
            await context.bot.send_message(partner_id, "Please give your Feedback about the Stranger!!", reply_markup=InlineKeyboardMarkup(k_partner))
        except: pass

async def relay_message(update, context):
    user_id = update.effective_user.id
    
    # FAST PATH: Check RAM First
    partner_id = ACTIVE_CHATS.get(user_id)
    
    # SLOW PATH: Check DB (If bot restarted)
    if not partner_id:
        conn = get_conn(); cur = conn.cursor()
        cur.execute("SELECT partner_id FROM users WHERE user_id = %s AND status='chatting'", (user_id,))
        row = cur.fetchone()
        cur.close(); release_conn(conn)
        if row and row[0]:
            partner_id = row[0]
            ACTIVE_CHATS[user_id] = partner_id # Repopulate RAM

    if partner_id:
        # üîµ WYR DISCUSSION PHASE
        if user_id in GAME_STATES and GAME_STATES[user_id].get("status") == "discussing":
            gd = GAME_STATES[user_id]
            try:
                # 1. Forward Explanation
                await update.message.copy(chat_id=partner_id, caption=f"üó£Ô∏è **Because...**")
                await update.message.reply_text("‚úÖ Explanation Sent.")
                
                # 2. Mark Explained
                if "explained" not in gd: gd["explained"] = []
                if user_id not in gd["explained"]: gd["explained"].append(user_id)
                
                # 3. Check if BOTH explained
                if len(gd["explained"]) >= 2:
                    await context.bot.send_message(user_id, "‚ú® **Both explained! Next Round...**")
                    await context.bot.send_message(partner_id, "‚ú® **Both explained! Next Round...**")
                    
                    # Reset State & Start Next Round
                    gd["status"] = "playing"
                    gd["explained"] = []
                    await asyncio.sleep(1.5)
                    # Assuming p1/p2 are stored in 'partner' or we derive them.
                    # Simple fix: Pass current user and partner
                    await send_wyr_round(context, user_id, partner_id)

            except Exception as e:
                print(f"WYR Relay Error: {e}")
            return

        # üü¢ GAME ANSWER LOGIC (STRICT TURN CHECK)
        if user_id in GAME_STATES and GAME_STATES[user_id].get("status") == "answering" and GAME_STATES[user_id].get("turn") == user_id:
            try: 
                await update.message.copy(chat_id=partner_id, caption=f"üó£Ô∏è **Answer** (from Game)")
                await update.message.reply_text("‚úÖ Answer Sent.")
                
                # Reset Status
                GAME_STATES[user_id]["status"] = "playing"
                if partner_id in GAME_STATES: GAME_STATES[partner_id]["status"] = "playing"
                
                # SWAP TURNS
                GAME_STATES[user_id]["turn"] = partner_id 
                GAME_STATES[partner_id]["turn"] = partner_id
                
                # Show Menu to Partner
                await send_tod_turn(context, partner_id)
                return 
            except Exception as e:
                print(f"Game Relay Error: {e}")

        # NORMAL CHAT RELAY
        if update.message.text:
            conn = get_conn(); cur = conn.cursor()
            cur.execute("INSERT INTO chat_logs (sender_id, receiver_id, message) VALUES (%s, %s, %s)", (user_id, partner_id, update.message.text))
            conn.commit(); cur.close(); release_conn(conn)
        
        try: await update.message.copy(chat_id=partner_id)
        except: await stop_chat(update, context)

# ==============================================================================
# üß© HELPERS & BUTTON HANDLER
# ==============================================================================
async def send_reroll_option(context: ContextTypes.DEFAULT_TYPE):
    user_id = context.job.data
    conn = get_conn(); cur = conn.cursor()
    cur.execute("SELECT status FROM users WHERE user_id = %s", (user_id,))
    status = cur.fetchone()
    
    # Only show if STILL searching
    if status and status[0] == 'searching':
        kb = [
            [InlineKeyboardButton("üîî Notify Me & Stop", callback_data="notify_me")],
            [InlineKeyboardButton("üì° Keep Searching", callback_data="keep_searching")]
        ]
        msg = (
            "üê¢ **It's quiet right now.**\n\n"
            "Want me to notify you when someone joins?\n\n"
            "_This is temporary because our bot is in the initial stage. "
            "When userbase increases, you will get connected immediately. "
            "Thanks for supporting!_"
        )
        try: await context.bot.send_message(user_id, msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
        except: pass
    cur.close(); release_conn(conn)

async def show_profile(update, context):
    user_id = update.effective_user.id
    conn = get_conn(); cur = conn.cursor()
    cur.execute("SELECT language, interests, karma_score, gender, age_range, region, mood FROM users WHERE user_id = %s", (user_id,))
    data = cur.fetchone(); cur.close(); release_conn(conn)
    text = f"üë§ **IDENTITY**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nüó£Ô∏è {data[0]}\nüè∑Ô∏è {data[1]}\nüöª {data[3]}\nüéÇ {data[4]}\nüåç {data[5]}\nüé≠ {data[6]}\nüõ°Ô∏è {data[2]}%"
    await update.message.reply_text(text, parse_mode='Markdown')

async def show_main_menu(update):
    try: 
        if update.message: await update.message.reply_text("üëã **Welcome to OmeTV Chatbot ü§ñ**", reply_markup=get_keyboard_lobby(), parse_mode='Markdown')
        elif update.callback_query: await update.callback_query.message.reply_text("‚è≥ **you are in waiting Lobby...Thanks for you patience **", reply_markup=get_keyboard_lobby(), parse_mode='Markdown')
    except: pass

async def handle_report(update, context, reporter, reported):
    conn = get_conn(); cur = conn.cursor()
    cur.execute("UPDATE users SET report_count = report_count + 1 WHERE user_id = %s RETURNING report_count", (reported,))
    cnt = cur.fetchone()[0]
    cur.execute("INSERT INTO reports (reporter_id, reported_id, reason) VALUES (%s, %s, 'Report')", (reporter, reported))
    conn.commit()
    if cnt >= 3:
        cur.execute("SELECT message FROM chat_logs WHERE sender_id = %s ORDER BY timestamp DESC LIMIT 5", (reported,))
        logs = [l[0] for l in cur.fetchall()]
        msg = f"üö® **REPORT (3+)**\nUser: `{reported}`\nLogs: {logs}"
        kb = [[InlineKeyboardButton(f"üî® BAN {reported}", callback_data=f"ban_user_{reported}")]]
        for a in ADMIN_IDS:
            try: await context.bot.send_message(a, msg, reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown')
            except: pass
    cur.close(); release_conn(conn)

async def update_user(user_id, col, val):
    conn = get_conn(); cur = conn.cursor()
    cur.execute(f"UPDATE users SET {col} = %s WHERE user_id = %s", (val, user_id))
    conn.commit(); cur.close(); release_conn(conn)

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    data = q.data
# RPS SUB-MENU
    if data == "rps_mode_select":
        kb = [[InlineKeyboardButton("Best of 3", callback_data="game_offer_Rock paper Scissors|3"), InlineKeyboardButton("Best of 5", callback_data="game_offer_Rock paper Scissors|5")]]
        await q.edit_message_text("üî¢ **Select Rounds:**", reply_markup=InlineKeyboardMarkup(kb)); return
    uid = q.from_user.id
    # NEW SETTINGS REDIRECTS
    if data == "set_gen_menu": await send_onboarding_step(update, 1); return
    if data == "set_age_menu": await send_onboarding_step(update, 2); return
    if data == "set_lang_menu": await send_onboarding_step(update, 3); return
    if data == "set_mood_menu": await send_onboarding_step(update, 5); return
    if data == "force_random": await perform_match(update, context, uid); return
    if data == "close_settings": await q.delete_message(); return
    # NOTIFY ME LOGIC
    # NOTIFY ME LOGIC (Pause & Lobby)
    if data == "notify_me":
        conn = get_conn(); cur = conn.cursor()
        cur.execute("UPDATE users SET status = 'waiting_notify' WHERE user_id = %s", (uid,))
        conn.commit(); cur.close(); release_conn(conn)
        
        await q.edit_message_text("‚úÖ **Paused.** I'll notify you when someone joins.", parse_mode='Markdown')
        await show_main_menu(update) # Force them back to Lobby so they are ready to click Start later
        return

    # KEEP SEARCHING LOGIC (Continue)
    if data == "keep_searching":
        await q.delete_message() # Just delete the warning, stay in queue
        return
    if data == "game_soon": await q.answer("üöß Coming Soon!", show_alert=True); return
    
    # GAME HANDLERS
    if data.startswith("game_offer_"): await offer_game(update, context, uid, data.split("_", 2)[2]); return
    if data.startswith("game_accept_"): pid = ACTIVE_CHATS.get(uid); await start_game_session(update, context, data.split("_", 2)[2], pid, uid) if pid else None; return
    if data == "game_reject": pid = ACTIVE_CHATS.get(uid); await context.bot.send_message(pid, "‚ùå Declined.") if pid else None; await q.edit_message_text("‚ùå Declined."); return
    
    # TRUTH OR DARE LOGIC (Fixed Flow)
    if data.startswith("tod_pick_"):
        mode = data.split("_")[2] # truth or dare
        partner_id = ACTIVE_CHATS.get(uid)
        
        # 1. Notify the person who clicked (You)
        await q.edit_message_text(f"‚úÖ You picked **{mode.upper()}**.\nWaiting for partner to ask...", parse_mode='Markdown')
        
        # 2. Send the Question Menu to the Partner (Asker)
        if partner_id:
            # FIX: Passing 'context' and 'partner_id' correctly
            await send_tod_options(context, partner_id, mode)
        return
    
    if data.startswith("tod_send_"): 
        gd = GAME_STATES.get(uid)
        if gd:
            q_text = gd["options"][int(data.split("_")[2])]
            pid = gd["partner"]
            
            # Send Question
            await context.bot.send_message(pid, f"üé≤ **QUESTION:**\n{q_text}\n\n*Type your answer...*", parse_mode='Markdown')
            await q.edit_message_text(f"‚úÖ Asked: {q_text}")
            
            # Update State: It is now PARTNER'S turn to answer. 
            # We DO NOT send the menu yet. We wait for text input.
            if pid in GAME_STATES: 
                GAME_STATES[pid]["status"] = "answering"
                GAME_STATES[pid]["turn"] = pid 
        return
    if data == "tod_manual": context.user_data["state"] = "GAME_MANUAL"; await q.edit_message_text("‚úçÔ∏è **Type your question now:**"); return
# ROCK PAPER SCISSORS LOGIC
    # ROCK PAPER SCISSORS (TOURNAMENT EDITION)
    if data.startswith("rps_"):
        move = data.split("_")[1]
        gd = GAME_STATES.get(uid)
        if not gd: return
        
        # 1. Save Move
        gd["moves"][uid] = move
        await q.edit_message_text(f"‚úÖ You chose **{move.upper()}**.\nWaiting for partner...")
        
        # 2. Check if both played
        partner_id = ACTIVE_CHATS.get(uid)
        if partner_id and partner_id in gd["moves"]:
            p_move = gd["moves"][partner_id]
            
            # 3. Calculate ROUND Winner
            r_res = "ü§ù Draw"
            winner = None # None, p1, or p2
            
            # Determine Offerer (p1) vs Accepter (p2) for scoring
            # We stored scores as s1 (for p1) and s2 (for p2)
            # We need to know who 'uid' is relative to the game owner
            # But simpler: Just track scores by ID? 
            # Let's use the 'turn' logic or just simple ID comparison? 
            # FAST FIX: Since both share the SAME dictionary object, we can just update gd['s1'] if uid < partner_id else...
            # Wait, easier: Just send the text.
            
            if move == p_move: r_res = "ü§ù Draw"
            elif (move == "rock" and p_move == "scissors") or \
                 (move == "paper" and p_move == "rock") or \
                 (move == "scissors" and p_move == "paper"):
                 r_res = f"üèÜ You ({move}) beat {p_move}!"
                 winner = uid
            else:
                 r_res = f"üíÄ You ({move}) lost to {p_move}!"
                 winner = partner_id

            # Update Scoreboard
            if winner == uid: gd[f"s_{uid}"] = gd.get(f"s_{uid}", 0) + 1
            elif winner == partner_id: gd[f"s_{partner_id}"] = gd.get(f"s_{partner_id}", 0) + 1
            
            # Get Current Scores
            sc_me = gd.get(f"s_{uid}", 0)
            sc_pa = gd.get(f"s_{partner_id}", 0)
            
            # 4. Check Tournament Status
            if gd["cur_r"] >= gd["max_r"]:
                # GAME OVER - FINAL RESULTS
                final_res = "aww...ü§ù **MATCH DRAW!**"
                if sc_me > sc_pa: final_res = "üèÜ **YOU WON THE MATCH!üçæ**"
                elif sc_pa > sc_me: final_res = "üíÄ **YOU LOST THE MATCH!**"
                
                p_final = "üèÜ **YOU WON THE MATCH!**" if "LOST" in final_res else ("üíÄ **YOU LOST THE MATCH!**" if "WON" in final_res else final_res)

                msg = f"üèÅ **FINAL SCORE (Best of {gd['max_r']})**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nYou: {sc_me} | Partner: {sc_pa}\n\n{final_res}"
                p_msg = f"üèÅ **FINAL SCORE (Best of {gd['max_r']})**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\nYou: {sc_pa} | Partner: {sc_me}\n\n{p_final}"
                
                await context.bot.send_message(uid, msg, parse_mode='Markdown', reply_markup=get_keyboard_game())
                await context.bot.send_message(partner_id, p_msg, parse_mode='Markdown', reply_markup=get_keyboard_game())
                
                # Cleanup
                gd["moves"] = {}
                # Keep state briefly or delete? Let's delete to prevent glitches
                del GAME_STATES[uid]
                del GAME_STATES[partner_id]
                
            else:
                # NEXT ROUND
                p_r_res = f"üèÜ You ({p_move}) beat {move}!" if winner == partner_id else (f"üíÄ You ({p_move}) lost to {move}!" if winner == uid else "ü§ù Draw")
                
                msg = f"üîî **Round {gd['cur_r']} Result:**\n{r_res}\n\nüìä Score: {sc_me} - {sc_pa}\n‚è≥ Next round..."
                p_msg = f"üîî **Round {gd['cur_r']} Result:**\n{p_r_res}\n\nüìä Score: {sc_pa} - {sc_me}\n‚è≥ Next round..."

                await context.bot.send_message(uid, msg, parse_mode='Markdown')
                await context.bot.send_message(partner_id, p_msg, parse_mode='Markdown')
                
                # Setup Next Round
                gd["cur_r"] += 1
                gd["moves"] = {}
                await asyncio.sleep(2)
                await send_rps_round(context, uid, partner_id)
        return

    # WOULD YOU RATHER LOGIC
    # WOULD YOU RATHER (SOCIAL ENGINE 2.0)
    if data.startswith("wyr_") and data != "wyr_skip":
        choice = data.split("_")[1].upper() # A or B
        gd = GAME_STATES.get(uid)
        if not gd: return
        
        # 1. Save Vote
        gd["moves"][uid] = choice
        await q.edit_message_text(f"‚úÖ You voted **Option {choice}**.\nWaiting for partner...")
        
        # 2. Check if both voted
        partner_id = ACTIVE_CHATS.get(uid)
        if partner_id and partner_id in gd["moves"]:
            p_choice = gd["moves"][partner_id]
            
            # 3. Analyze Compatibility
            match_text = ""
            if choice == p_choice:
                gd["streak"] = gd.get("streak", 0) + 1
                s = gd["streak"]
                match_text = f"üî• **100% MATCH!** (Streak: {s})"
                if s == 2: match_text += "\n*2 in a row! Are you twins?* üëØ"
                if s >= 3: match_text += "\n*PERFECT SYNC! Soulmates?* üíç"
            else:
                gd["streak"] = 0
                match_text = "‚ö° **DIFFERENT POV!** (Streak Reset)"

            # 4. Announce & Trigger "Interrogation Phase"
            msg = f"üìä **RESULTS:**\n\nüë§ You: **{choice}**\nüë§ Partner: **{p_choice}**\n\n{match_text}\n\nüëá **Tell your partner WHY you chose that!**"
            p_msg = f"üìä **RESULTS:**\n\nüë§ You: **{p_choice}**\nüë§ Partner: **{choice}**\n\n{match_text}\n\nüëá **Tell your partner WHY you chose that!**"
            
            # Switch State to "Discussion"
            gd["status"] = "discussing"
            gd["explained"] = [] # Reset explanation tracker
            
            # Add a Skip Button (Emergency Exit)
            kb = [[InlineKeyboardButton("‚è≠Ô∏è Skip Discussion", callback_data="wyr_skip")]]
            
            await context.bot.send_message(uid, msg, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup(kb))
            await context.bot.send_message(partner_id, p_msg, parse_mode='Markdown', reply_markup=InlineKeyboardMarkup(kb))
            
            # Reset moves for safety
            gd["moves"] = {}
        return
    
    # WYR SKIP HANDLER
    if data == "wyr_skip":
        gd = GAME_STATES.get(uid)
        pid = ACTIVE_CHATS.get(uid)
        
        # Only process if in discussing phase
        if gd and gd.get("status") == "discussing":
            # 1. Initialize 'explained' list if missing
            if "explained" not in gd: gd["explained"] = []
            
            # 2. Mark this user as DONE (Treat Skip as an 'Answer')
            if uid not in gd["explained"]:
                gd["explained"].append(uid)
                await q.edit_message_text("‚è≠Ô∏è **You skipped.** Waiting for partner...")
                if pid: await context.bot.send_message(pid, "‚è≠Ô∏è **Partner skipped discussion.**")
            else:
                await q.answer("‚è≥ Waiting for partner...", show_alert=True)
                return

            # 3. Check if BOTH are done (Meaning: Both Skipped, or 1 Skipped + 1 Answered)
            if len(gd["explained"]) >= 2:
                # Notify
                if pid: await context.bot.send_message(pid, "‚ú® **Next Round...**")
                await context.bot.send_message(uid, "‚ú® **Next Round...**")
                
                # Reset State & Start Next Round
                gd["status"] = "playing"
                await asyncio.sleep(1.5)
                if pid: await send_wyr_round(context, uid, pid)
        return

    # ONBOARDING
    if data.startswith("set_gen_"): await update_user(uid, "gender", data.split("_")[2]); await send_onboarding_step(update, 2); return
    if data.startswith("set_age_"): await update_user(uid, "age_range", data.split("_")[2]); await send_onboarding_step(update, 3); return
    if data.startswith("set_lang_"): await update_user(uid, "language", data.split("_")[2]); await send_onboarding_step(update, 4); return
    if data.startswith("set_reg_"): await update_user(uid, "region", data.split("_")[2]); await send_onboarding_step(update, 5); return
    if data.startswith("set_mood_"): await update_user(uid, "mood", data.split("_")[2]); context.user_data["state"] = "ONBOARDING_INTEREST"; await send_onboarding_step(update, 6); return
    if data == "onboarding_done": context.user_data["state"] = None; await show_main_menu(update); return
    if data == "restart_onboarding": await send_onboarding_step(update, 1); return

    # ADMIN
    if uid in ADMIN_IDS:
        if data == "admin_broadcast_info": 
            try: await q.edit_message_text("üì¢ Type `/broadcast msg`", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô", callback_data="admin_home")]])); return
            except: pass
        if data == "admin_home": await admin_panel(update, context); return
        if data == "admin_users":
            conn = get_conn(); cur = conn.cursor(); cur.execute("SELECT user_id, first_name FROM users ORDER BY joined_at DESC LIMIT 10"); users = cur.fetchall(); cur.close(); release_conn(conn)
            msg = "üìú **Recent:**\n" + "\n".join([f"‚Ä¢ {u[1]} (`{u[0]}`)" for u in users])
            try: await q.edit_message_text(msg, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô", callback_data="admin_home")]]), parse_mode='Markdown'); return
            except: pass
        if data == "admin_reports":
            conn = get_conn(); cur = conn.cursor(); cur.execute("SELECT user_id, report_count FROM users WHERE report_count > 0 LIMIT 5"); users = cur.fetchall(); cur.close(); release_conn(conn)
            kb = []; 
            for u in users: kb.append([InlineKeyboardButton(f"üî® {u[0]}", callback_data=f"ban_user_{u[0]}"), InlineKeyboardButton(f"‚úÖ {u[0]}", callback_data=f"clear_user_{u[0]}")])
            kb.append([InlineKeyboardButton("üîô", callback_data="admin_home")])
            try: await q.edit_message_text("‚ö†Ô∏è **Reports:**", reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown'); return
            except: pass
        if data == "admin_banlist":
            conn = get_conn(); cur = conn.cursor(); cur.execute("SELECT user_id, banned_until FROM users WHERE banned_until > NOW() LIMIT 5"); users = cur.fetchall(); cur.close(); release_conn(conn)
            kb = []; 
            for u in users: kb.append([InlineKeyboardButton(f"‚úÖ Unban {u[0]}", callback_data=f"unban_user_{u[0]}")])
            kb.append([InlineKeyboardButton("üîô", callback_data="admin_home")])
            try: await q.edit_message_text("üö´ **Bans:**", reply_markup=InlineKeyboardMarkup(kb), parse_mode='Markdown'); return
            except: pass
        if data == "admin_feedbacks":
            conn = get_conn(); cur = conn.cursor(); cur.execute("SELECT message FROM feedback ORDER BY timestamp DESC LIMIT 5"); rows = cur.fetchall(); cur.close(); release_conn(conn)
            txt = "\n".join([r[0] for r in rows]) or "None"
            try: await q.edit_message_text(f"üì® **Feed:**\n{txt}", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô", callback_data="admin_home")]]), parse_mode='Markdown'); return
            except: pass
        
        if data.startswith("ban_user_"): await admin_ban_command(update, context); return
        if data.startswith("clear_user_"):
            tid = int(data.split("_")[2]); conn = get_conn(); cur = conn.cursor(); cur.execute("UPDATE users SET report_count = 0 WHERE user_id = %s", (tid,)); conn.commit(); cur.close(); release_conn(conn)
            try: await q.edit_message_text(f"‚úÖ Cleared.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô", callback_data="admin_reports")]])); return
            except: pass
        if data.startswith("unban_user_"):
            tid = int(data.split("_")[2]); conn = get_conn(); cur = conn.cursor(); cur.execute("UPDATE users SET banned_until = NULL WHERE user_id = %s", (tid,)); conn.commit(); cur.close(); release_conn(conn)
            try: await q.edit_message_text("‚úÖ Unbanned.", reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("üîô", callback_data="admin_banlist")]])); return
            except: pass

    # RATE & GENERAL
    if data.startswith("rate_"):
        act, target = data.split("_")[1], int(data.split("_")[2])
        if act == "report": await handle_report(update, context, uid, target); await q.edit_message_text("‚ö†Ô∏è Reported.")
        else:
            sc = 1 if act == "like" else -1
            conn = get_conn(); cur = conn.cursor(); cur.execute("INSERT INTO user_interactions (rater_id, target_id, score) VALUES (%s, %s, %s)", (uid, target, sc)); conn.commit(); cur.close(); release_conn(conn)
            await q.edit_message_text("‚úÖ Sent.")
    
    if data == "action_search": await start_search(update, context); return
    if data == "main_menu": await show_main_menu(update); return
    if data == "stop_search": await stop_search_process(update, context); return
if __name__ == '__main__':
    if not BOT_TOKEN: print("ERROR: Config missing")
    else:
        init_db()
        flask_thread = threading.Thread(target=run_flask); flask_thread.daemon = True; flask_thread.start()
        req = HTTPXRequest(connect_timeout=60, read_timeout=60)
        app = ApplicationBuilder().token(BOT_TOKEN).request(req).build()
        
        app.add_handler(CommandHandler("start", start))
        app.add_handler(CommandHandler("admin", admin_panel))
        app.add_handler(CommandHandler("ban", admin_ban_command))
        app.add_handler(CommandHandler("warn", admin_warn_command))
        app.add_handler(CommandHandler("broadcast", admin_broadcast_execute))
        app.add_handler(CommandHandler("help", help_command))
        app.add_handler(CommandHandler("feedback", handle_feedback_command))
        
        app.add_handler(MessageHandler(filters.TEXT & (~filters.COMMAND), handle_text_input))
        app.add_handler(CallbackQueryHandler(button_handler))
        app.add_handler(MessageHandler(filters.ALL, relay_message))
        
        print("ü§ñ PHASE 20 BOT LIVE")
        app.run_polling()
